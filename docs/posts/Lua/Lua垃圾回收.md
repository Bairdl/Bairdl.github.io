---
description: Lua 垃圾回收的介绍。
tags:
  - lua
---

# Lua 垃圾回收

Lua 提供了自动内存管理的功能。  
Lua 通过运行一个垃圾回收器来自动管理内存，以收集所有不再使用的对象。  
自动内存管理适用于所有内存，包括字符串、表、用户数据、函数、线程等。  

当Lua确定某个对象在其程序的正常执行过程中将不会再被访问时，该对象即被视为“死亡”。  
Lua 何时进行垃圾回收是未知的。  

Lua 的垃圾回收器有两种工作模式：增量式和分代式：

- 增量式：垃圾收集器与程序的其他部分交替执行，从而减少长时间停顿。
- 分代式：基于对象的生命周期进行优化。

默认情况下， Lua 采用增量式。

可以通过在 C 语言中调用 `lua_gc` 函数或在 Lua 中调用 `collectgarbage` 函数来改变 GC 模式和参数，也可以用这些函数直接控制收集器的行为（比如停止和重新启动收集器等）。  

## 1 增量式垃圾收集 (Incremental Garbage Collection)

在增量模式下，垃圾收集器（GC）通过一系列小步骤完成标记-清除（mark-and-sweep）操作，这些步骤与程序的执行交替进行。这种设计减少了长时间停顿的可能性。

### 控制参数

1. 垃圾收集器暂停时间（Garbage-Collector Pause）
   - 控制新GC周期开始前的等待时间。
   - 当内存使用量达到上一次收集后内存使用量的`n%`时，启动新的GC周期。
   - 较大的值使GC更加“懒惰”（less aggressive）。例如：
     - `pause = 200`：当内存使用量增加一倍时，启动新周期。
     - `pause = 100`或更小：GC不会等待，立即启动新周期。
   - 默认值为200，最大值为1000。

2. 垃圾收集器步长乘数（Garbage-Collector Step Multiplier）
   - 控制GC的速度相对于内存分配的速度。
   - 每分配1KB内存时，GC会标记或清理相应数量的元素。
   - 较大的值使GC更加激进，但也会增加每次步长的工作量。
   - 不建议使用小于100的值，因为这会使GC过慢，甚至无法完成一个周期。
   - 默认值为100，最大值为1000。

3. 垃圾收集器步长大小（Garbage-Collector Step Size）  
   - 控制每次步长的大小，即解释器在执行一步之前分配的字节数。
   - 参数是**对数形式**，值为`n`表示每次步长之间分配`2^n`字节。
   - 较大的值（如60）会使GC变成“停止世界”（stop-the-world）模式，即一次性完成整个GC周期。
   - 默认值为13，相当于每次步长处理约8KB的数据。

---

## 2 分代式垃圾收集 (Generational Garbage Collection)

分代模式基于对象的生命周期优化GC行为，假设大多数对象的生命周期较短。因此，它会频繁地执行**小规模收集**（minor collections），只遍历最近创建的对象。如果小规模收集后内存使用仍然超过某个限制，则执行**大规模收集**（major collection），遍历所有对象。

### 控制参数

1. **小规模收集乘数（Minor Multiplier）**  
   - 控制小规模收集的频率。
   - 对于乘数`x`，当内存使用量比上次大规模收集后的使用量增长了`x%`时，执行小规模收集。
   - 默认值为20，最大值为200。

2. **大规模收集乘数（Major Multiplier）**  
   - 控制大规模收集的频率。
   - 对于乘数`x`，当内存使用量比上次大规模收集后的使用量增长了`x%`时，执行大规模收集。
   - 默认值为100，最大值为1000。

---

## 3 垃圾收集元方法 (Garbage-Collection Metamethods)

Lua允许为表和用户数据设置**终结器（finalizers）**，这些终结构通常用于协调Lua的垃圾收集与外部资源管理（如关闭文件、网络连接或释放自定义内存）。

### 如何设置终结器

- 设置对象的元表，并在元表中添加`__gc`字段。
- 如果先设置了没有`__gc`字段的元表，后来才添加了`__gc`字段，那么该对象不会被标记为需要终结。

### 终结器的行为

1. 当一个对象被标记为死亡（dead）时，Lua不会立即将其回收，而是将其放入一个列表中。
2. 在GC周期结束时，Lua会按照**反向顺序**调用这些终结器（即最后被标记的对象的终结器最先被调用）。
3. 终结器可以访问并复活（resurrect）对象，使其再次成为活动对象。复活通常是临时的，但在某些情况下（如将对象存储到全局变量中），复活可能是永久的。
4. 如果终结器重新标记对象以进行终结，则该对象的终结器会在下一个GC周期中再次被调用。

### 注意事项

- 终结器不能让出（yield）或运行垃圾收集器。
- 终结器中的错误会生成警告，但不会传播。
- 在关闭Lua状态（`lua_close`）时，所有带有终结器的对象都会被调用，且按照反向顺序执行。

---

## 4 弱表 (Weak Tables)

弱表是一种特殊的表，其中的键或值是**弱引用**。弱引用会被垃圾收集器忽略，也就是说，如果某个对象仅通过弱引用来引用，那么它会被GC回收。

### 弱表的类型

1. 弱键（Weak Keys）
   - 如果键被回收，整个键值对会被移除。
2. 弱值（Weak Values）  
   - 如果值被回收，整个键值对会被移除。
3. 弱键和弱值（Weak Keys and Values）  
   - 键和值都可以被回收，任一方被回收时，整个键值对都会被移除。

### 控制方式

- 弱表的行为由其元表的`__mode`字段控制：
  - `"k"`：弱键。
  - `"v"`：弱值。
  - `"kv"`：弱键和弱值。

### 特殊行为

- Ephemeron 表（弱键+强值）：  
  - 值只有在其键可访问时才会被认为是可达的。
  - 如果键仅通过其值引用，键值对会被移除。
- 复活对象（Resurrected Objects）：
  - 在终结器运行前，复活对象会从弱值中移除，但从弱键中移除则发生在终结器运行后的下一次GC周期。
- 非显式构造的对象：
  - 数字、轻量级C函数等不会被GC回收，也不会从弱表中移除。
  - 字符串虽然受GC管理，但它们按值比较，类似于值类型，不会从弱表中移除。

### 注意事项

- 修改弱表的`__mode`字段可能需要等到下一次GC周期才能生效。
- 如果弱表本身是复活对象的一部分，它可能要到下一次GC周期才能被正确清理。

---

## 总结

Lua的垃圾收集机制提供了灵活的配置选项，可以根据程序的需求选择不同的模式和参数。无论是增量式还是分代式，都能有效减少长时间停顿的影响。此外，弱表和终结器为开发者提供了额外的工具来管理复杂场景下的内存和资源。
