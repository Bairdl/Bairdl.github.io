---
description: 常用的排序算法的介绍，代码模板，优缺点，示例等。
tags:
    - 算法
    - 排序算法
---

# 常用的排序算法

## 概览

| 算法名称 | 核心思想                                                                                                                             | 是否稳定 | 时间复杂度                                    | 空间复杂度        | 备注  |
| ---- | -------------------------------------------------------------------------------------------------------------------------------- | ---- | ---------------------------------------- | ------------ | --- |
| 冒泡排序 | 重复地遍历要排序的数组，依次比较相邻的两个元素                                                                                                          | 稳定   | 最好情况：$O(n)$；</br>平均和最坏情况：$O(n^2)$ 。</br>   | $O(1)$       |     |
| 选择排序 | 不断地从待排序数列中选出最小（或是最大）的一个元素，将其放在已排序序列的末尾，直到整个序列有序。                                                                                 | 不稳定  | $O(n^2)$。                                | $O(1)$       |     |
| 插入排序 | 对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。                                                                                                 | 稳定   | 最好情况：$O(n)$；</br>平均和最坏情况：$O(n^2)$。        | $O(1)$       |     |
| 快速排序 | 选择一个“基准”元素，通过一趟排序将待排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。                  | 不稳定  | 最好和平均情况：$O(n\log{n})$；</br>最坏情况：$O(n^2)$。 | $O(\log{n})$ |     |
| 归并排序 | 将一个大的数组分成两个大致相等的小数组分别进行排序，然后将这两个排好序的小数组合并成一个有序的大数组。                                                                              | 稳定   | $O(n \log{n})$                           | $O(n)$       |     |
| 堆排序  | 它利用了堆这种数据结构所具备的性质，即最大堆（或最小堆）的根节点总是存储着堆中的最大值（或最小值）。通过构建最大堆，我们可以不断地从堆中移除最大的元素，并将其放到数组的末尾，从而实现排序。                                   | 不稳定  | $O(n \log{n})$                           | $O(1)$       |     |
| 计数排序 | 通过计算每个数值出现的次数来确定每个元素在输出数组中的位置。                                                                                                   | 稳定   | $O(n+k)$                                 | $O(k)$       |     |
| 桶排序  | 基于将数据分发到多个“桶”中，每个桶单独进行排序（通常使用其他排序算法如快速排序），然后依次连接这些桶来得到最终的排序结果。                                                                   | 稳定   | $O(n+k)$                                 | $O(n+k)$     |     |
| 基数排序 | 通过逐位比较数字来实现排序（从最低有效位到最高有效位或相反）。基数排序可以分为两种：LSD（Least Significant Digit）和 MSD（Most Significant Digit），分别从最不重要的位（右边）和最重要的位（左边）开始排序。 | 稳定   | $O(n*k)$                                 | $O(n+k)$     |     |
| 希尔排序 | 通过比较距离较远的元素来减少数据移动次数，从而更快地将数组变得接近有序。随着排序的进行，逐步减小这个距离，直到它变为 1，此时的希尔排序就退化为普通的插入排序。                                                 | 不稳定  | O(n log n)                               | O(1)         |     |

## 1. 冒泡排序（Bubble Sort）

### 冒泡排序 核心思想

**重复地遍历要排序的数组，依次比较相邻的两个元素**，如果它们的顺序错误就交换它们的位置。  
直到没有再需要交换的操作，说明数组排序完成。

**稳定排序算法**。

### 冒泡排序 实现步骤

1. 从数列的第一个元素开始，比较相邻的两个元素。如果第一个比第二个大（升序），就交换它们的位置。
2. 对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。**这步做完后，最后的元素会是最大的数**。
3. 针对所有的元素重复以上的步骤，除了已经排好序的元素。
4. 持续每次对剩下的元素重复上述的操作，直到没有任何一对元素需要比较。

### 冒泡排序 代码模板

``` java
public void bubbleSort(int arr[]){
    int n  =arr.length;
    for(int i=0; i<n-1; i++){
        for(int j = 0; j<n-1-i; j++){
            if(arr[j] > arr[j+1]){
                int temp = arr[j];
                arr[j] = arr[j+1];
                arr[j+1] = temp;
            }
        }
    }
} 
```

### 冒泡排序 优缺点及应用场景

- 优点：简单易懂，容易实现。
- 缺点：效率低，**特别是在处理大数据集时表现不佳**。
- 应用场景：教育学习；小规模数据集；几乎排好序的数据。

### 冒泡排序 复杂度

- 时间复杂度：
  - 最好情况：$O(n)$（当数组已经是有序的情况下）。
  - 平均和最坏情况：$O(n^2)$ 。
- 空间复杂度：$O(1)$ 。

### 冒泡排序 手动排序示例

假设有数组 `[5,1,4,2,8]`：

1. 第一次遍历：比较 `5` 和 `1`，交换 → `[1,5,4,2,8]`。
   - 继续比较 `5` 和 `4`，交换 → `[1,4,5,2,8]` 。
   - 继续比较 `5` 和 `2`, 交换 → `[1,4,2,5,8]` 。
   - 比较 `5` 和 `8`，不交换 → `[1,4,2,5,8]` 。
2. 第二次遍历：比较 `1` 和 `4`，不交换 → `[1,4,2,5,8]` 。
   - 比较 `4` 和 `2`，交换 → `[1,2,4,5,8]` 。
   - 比较 `4` 和 `5`，不交换 → `[1,2,4,5,8]` 。
3. 第三次遍历：比较 `1` 和 `2`，不交换 → `[1,2,4,5,8]` 。
   - 比较 `2` 和 `4`，不交换 → `[1,2,4,5,8]` 。

此时数组已排序完成 `[1,2,4,5,8]` 。

## 2. 选择排序（Selection Sort）

### 选择排序 核心思想

不断地从待排序数列中选出最小（或是最大）的一个元素，将其放在已排序序列的末尾，直到整个序列有序。

### 选择排序 实现步骤

1. 首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。
2. 然后，继续从剩余未排序元素中寻找最小（大）元素，然后放到已排序序列的末尾。
3. 重复第二步，直到所有元素排序完毕。

### 选择排序 代码模板

``` java
public void sort(int[] arr) {
    int n = arr.length;

    // 一步步移动未排序序列的遍界
    for (int i = 0; i < n-1; i++) {
        // 在未排序序列中找到最小元素
        int min_idx = i;
        for (int j = i+1; j < n; j++)
            if (arr[j] < arr[min_idx])
                min_idx = j;

        // 与队首元素交换找到的最小元素
        int temp = arr[min_idx];
        arr[min_idx] = arr[i];
        arr[i] = temp;
    }
}
```

### 选择排序 优缺点及应用场景

- 优点：实现简单；**性能与输入无关**，因此对数据量小或着几乎排好序的数据集来说，表现良好。
- 缺点：不稳定；即使输入数据有序，时间复杂度也不会改变，且在处理大数据集时效率较低。
- 应用场景：适合于对小规模数据进行排序，或者当交换成本较高时使用，因为选择排序的交换次数相对较少。

### 选择排序 复杂度

- 时间复杂度：$O(n^2)$。
- 空间复杂度：$O(1)$。

### 选择排序 是否稳定

**不稳定的排序算法**，最小元素会直接与开始元素交换，可能会破坏相同元素的相对位置。  
比如 `[5, 6, 6, 5, 4]`，第一次遍历后 -> `[4, 6, 6, 5, 5]`，两个 5 的相对位置变化了。

### 选择排序 手动排序示例

假设我们有一个数组 `[64, 25, 12, 22, 11]`。

1. 初始状态：`[64, 25, 12, 22, 11]`
   - 在未排序部分找到最小值 `11`，与第一个元素交换 -> `[11, 25, 12, 22, 64]`
2. 第二趟：忽略已排序部分 `[11]`，从未排序部分 `[25, 12, 22, 64]` 中找到最小值 `12`，与第二个元素交换 -> `[11, 12, 25, 22, 64]`
3. 第三趟：忽略已排序部分 `[11, 12]`，从未排序部分 `[25, 22, 64]` 中找到最小值 `22`，与第三个元素交换 -> `[11, 12, 22, 25, 64]`
4. 第四趟：忽略已排序部分 `[11, 12, 22]`，从未排序部分 `[25, 64]` 中找到最小值 `25`，与第四个元素位置不变，因为已经是正确的 -> `[11, 12, 22, 25, 64]`

最终结果为已排序的数组 `[11, 12, 22, 25, 64]`。

## 3. 插入排序 （Insertion Sort）

### 插入排序 核心思想

它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。  
插入排序在实现上，通常采用 in-place 排序（即只需用到 O(1)的额外空间的排序），因此空间复杂度较低。

### 插入排序 实现步骤

1. 从第一个元素开始，该元素可以认为已经被排序。
2. 取出下一个元素，在已经排序的元素序列中从后向前扫描。
3. 如果被扫描的元素（已排序）大于新元素，将该元素移到下一位置。
4. 重复步骤 3，直到找到已排序的元素小于或者等于新元素的位置。
5. 将新元素插入到该位置。
6. 重复步骤 2-5。

### 插入排序 JAVA 代码模板

```java
public void sort(int arr[]) {
    int n = arr.length;
    for (int i = 1; i < n; ++i) {
        int key = arr[i]; // 目标排序元素
        int j = i - 1;

        // 从后向前扫描已排序序列，如果已排序的元素大于目标，则将其向有移动一个位置
        while (j >= 0 && arr[j] > key) {
            arr[j + 1] = arr[j];
            j = j - 1;
        }
        // 当前位置 arr[j] <= key，目标元素插入在其后，也就是 arr[j+1]
        arr[j + 1] = key;
    }
}
```

### 插入排序 优缺点及应用场景

- **优点**：实现简单，对于小规模数据集非常有效；稳定；空间复杂度为 O(1)。
- **缺点**：效率对于大数据集来说较低，时间复杂度为 O(n^2)。
- **应用场景**：数据量较小的情况，基本有序的数据集。

### 插入排序 复杂度

- 时间复杂度：
  - 最好情况：O(n) 当数组已经是有序的时候。
  - 平均和最坏情况：O(n^2)。
- 空间复杂度：O(1)，因为它是原地排序算法。

### 插入排序 是否稳定

插入排序**是稳定的排序算法**，因为它不会改变相同元素的相对顺序。

### 插入排序 手动排序示例

假设我们有一个数组 `[12, 11, 13, 5, 6]`。

1. 初始状态：`[12, 11, 13, 5, 6]`
   - 比较 `12` 和 `11`，由于 `11` 更小，交换它们 -> `[11, 12, 13, 5, 6]`

2. 第二趟：忽略已排序部分 `[11, 12]`，比较 `13`，由于 `13` 已经正确位置，不进行操作 -> `[11, 12, 13, 5, 6]`

3. 第三趟：忽略已排序部分 `[11, 12, 13]`，取出 `5`，与前面每个数比较并移动，最终放置于起始位置 -> `[5, 11, 12, 13, 6]`

4. 第四趟：忽略已排序部分 `[5, 11, 12, 13]`，取出 `6`，与前面每个数比较并移动，最终放在 `5` 和 `11` 之间 -> `[5, 6, 11, 12, 13]`

经过上述步骤，数组变为有序数组 `[5, 6, 11, 12, 13]`。

## 4. 快速排序 （Quick Sort）

### 快速排序 核心思想

快速排序是一种高效的排序算法，采用分治法策略。  
它的基本思想是选择一个“基准”元素，通过一趟排序将待排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。

### 快速排序 实现步骤

1. 从数列中挑出一个元素作为"基准"(pivot)。
2. 重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（相同的数可以放到任一边）。在这个分区操作结束后，该基准就处于数列的中间位置。这个称为分区操作。
3. 对左右两个子集重复上述步骤，直到每个子集只剩下一个元素为止。

### 快速排序 JAVA代码模板

```java
public class QuickSort {

    // 分区函数，用于将数组划分为两部分，并返回基准元素的正确位置
    int partition(int arr[], int low, int high) {
        int pivot = arr[high]; // 选择最后一个元素作为基准（pivot）
        int i = (low - 1); // i 是小于基准的元素的索引

        // 遍历从 low 到 high-1 的所有元素
        for (int j = low; j < high; j++) {
            // 如果当前元素小于或等于基准值
            if (arr[j] <= pivot) {
                i++; // 增加小于基准的元素的索引
                // 交换 arr[i] 和 arr[j]
                int temp = arr[i];
                arr[i] = arr[j];
                arr[j] = temp;
            }
        }

        // 将基准元素放到正确的位置
        int temp = arr[i + 1];
        arr[i + 1] = arr[high];
        arr[high] = temp;

        return i + 1; // 返回基准元素的索引
    }

    // 快速排序的主函数
    void sort(int arr[], int low, int high) {
        // 如果 low 小于 high，则继续递归排序
        if (low < high) {
            // 调用分区函数，获取基准元素的正确位置
            int pi = partition(arr, low, high);

            // 对基准左侧的子数组进行递归排序
            sort(arr, low, pi - 1);

            // 对基准右侧的子数组进行递归排序
            sort(arr, pi + 1, high);
        }
    }
}
```

### 快速排序 优缺点及应用场景

- **优点**：平均情况下时间复杂度为O(n log n)，在大多数实际应用中效率高；它是原地排序算法，所需额外空间少。
- **缺点**：最坏情况下时间复杂度为O(n^2)，尤其是在面对已经排好序或接近排好序的数据时；不稳定。
- **应用场景**：广泛应用于需要高效排序的应用场景，**特别是对于较大的数据集**。

### 快速排序 复杂度

- 时间复杂度：
  - 最好和平均情况：$O(n\log{n})$
  - 最坏情况：$O(n^2)$（当每次选取的基准都是当前序列的最大或最小值时）
- 空间复杂度：$O(\log{n})$ （因为递归调用栈）

### 快速排序 是否稳定

快速排序**不是稳定的排序算法**，因为在交换过程中可能会改变相同元素的相对顺序。

### 快速排序 手动排序示例

假设我们有一个数组 `[10, 7, 8, 9, 1, 5]`。

1. 选择第一个元素 `10` 作为基准，经过一轮比较和交换后，结果可能为 `[5, 7, 8, 9, 1, 10]`，此时 `10` 已经在正确的位置上。
2. 对 `[5, 7, 8, 9, 1]` 进行同样的操作，选择 `5` 作为基准，由于 `5` 已经是最小的，所以这一部分不需要变动。
3. 对 `[7, 8, 9, 1]` 进行操作，选择 `1` 作为基准，最终这部分变为 `[1, 7, 8, 9]`。
4. 继续对 `[7, 8, 9]` 操作，选择 `7` 作为基准，无需调整，然后对 `[8, 9]` 操作，最后得到完全排序的数组 `[1, 5, 7, 8, 9, 10]`。

请注意，在手动示例中，具体的实现细节如选择哪个元素作为基准、如何进行分区等，可能会根据不同的实现而有所变化。上述步骤提供了一个简化的视角来理解快速排序的工作原理。

## 5. 归并排序 （Merge Sort）

### 归并排序 核心思想

归并排序是一种基于分治法的排序算法。  
其基本思想是将一个大的数组分成两个大致相等的小数组分别进行排序，然后将这两个排好序的小数组合并成一个有序的大数组。这个过程递归地应用于每个小数组，直到数组不能再分割为止（即每个子数组只有一个元素）。

### 归并排序 实现步骤

1. **分解**：将数组不断地二分，直到每个子数组仅包含一个元素。
2. **解决**：对这些单元素数组认为它们已经是有序的。
3. **合并**：逐步合并相邻的子数组，每次合并都会产生一个新的有序数组，直到所有元素被合并回原数组，形成一个完全有序的数组。

### 归并排序 JAVA 代码模板

```java
public class MergeSort {
    // 合并函数，用于合并两个有序子数组
    void merge(int arr[], int left, int mid, int right) {
        // 找出左右两边数组的大小
        int n1 = mid - left + 1;
        int n2 = right - mid;

        // 创建临时数组
        int L[] = new int[n1];
        int R[] = new int[n2];

        // 复制数据到临时数组 L[] 和 R[]
        for (int i = 0; i < n1; ++i)
            L[i] = arr[left + i];
        for (int j = 0; j < n2; ++j)
            R[j] = arr[mid + 1 + j];

        // 合并临时数组到 arr[left..right]
        int i = 0, j = 0;
        int k = left;
        while (i < n1 && j < n2) {
            if (L[i] <= R[j]) {
                arr[k] = L[i];
                i++;
            } else {
                arr[k] = R[j];
                j++;
            }
            k++;
        }

        // 拷贝 L[] 中剩余的元素
        while (i < n1) {
            arr[k] = L[i];
            i++;
            k++;
        }

        // 拷贝 R[] 中剩余的元素
        while (j < n2) {
            arr[k] = R[j];
            j++;
            k++;
        }
    }

    // 主函数，用于递归地排序子数组
    void sort(int arr[], int left, int right) {
        if (left < right) {
            // 找出中间点
            int mid = (left + right) / 2;

            // 递归排序左边和右边
            sort(arr, left, mid);
            sort(arr, mid + 1, right);

            // 合并已排序的部分
            merge(arr, left, mid, right);
        }
    }
}
```

### 归并排序 优缺点及应用场景

- **优点**：稳定；时间复杂度为 $O(n \log{n})$，无论在最好、平均还是最坏情况下都表现良好；适用于链表排序。
- **缺点**：需要额外的空间来存储临时数组，空间复杂度为 $O(n)$。
- **应用场景**：适用于处理大数据集的情况，**特别是当内存不是限制因素时**。

### 归并排序 复杂度

- 时间复杂度：
  - 最好、平均和最坏情况均为 $O(n \log{n})$
- 空间复杂度：$O(n)$

### 归并排序 是否稳定

归并排序是**稳定的排序算法**，因为它保证了相同元素的相对顺序不会改变。

### 归并排序 手动排序示例

假设我们有一个数组 `[38, 27, 43, 3, 9, 82, 10]`。

1. 首先将数组分成两部分：`[38, 27, 43]` 和 `[3, 9, 82, 10]`
   - 对 `[38, 27, 43]` 分成 `[38]` 和 `[27, 43]`
     - 对 `[27, 43]` 分成 `[27]` 和 `[43]`，合并得到 `[27, 43]`
     - 合并 `[38]` 和 `[27, 43]` 得到 `[27, 38, 43]`
   - 对 `[3, 9, 82, 10]` 分成 `[3, 9]` 和 `[82, 10]`
     - 对 `[3, 9]` 直接合并得到 `[3, 9]`
     - 对 `[82, 10]` 分成 `[82]` 和 `[10]`，合并得到 `[10, 82]`
     - 合并 `[3, 9]` 和 `[10, 82]` 得到 `[3, 9, 10, 82]`
2. 最后合并 `[27, 38, 43]` 和 `[3, 9, 10, 82]` 得到最终的排序结果 `[3, 9, 10, 27, 38, 43, 82]`

通过上述步骤，我们可以看到数组是如何一步步被分成最小单元，再逐级合并直至完成排序的。

## 6. 堆排序 （Heap Sort）

### 堆排序 核心思想

堆排序是一种基于二叉堆数据结构的比较排序算法。  
它利用了堆这种数据结构所具备的性质，即最大堆（或最小堆）的根节点总是存储着堆中的最大值（或最小值）。通过构建最大堆，我们可以不断地从堆中移除最大的元素，并将其放到数组的末尾，从而实现排序。

### 堆排序 实现步骤

1. **构建最大堆**：首先将待排序的数组构造成一个最大堆。
2. **交换和重建堆**：将堆顶元素（最大值）与最后一个未排序的元素交换位置，然后将剩余的元素重新调整为最大堆。重复此过程直到所有元素都被排序。

### 堆排序 JAVA 代码模板

```java
public class HeapSort {
    public void sort(int arr[]) {
        int n = arr.length;

        // 构建最大堆
        for (int i = n / 2 - 1; i >= 0; i--)
            heapify(arr, n, i);

        // 一个个取出元素
        for (int i=n-1; i>=0; i--) {
            // 将当前根（最大值）移到数组末尾
            int temp = arr[0];
            arr[0] = arr[i];
            arr[i] = temp;

            // 调整堆以保证剩下的i个元素仍然是最大堆
            heapify(arr, i, 0);
        }
    }

    // 对arr[]进行堆调整
    void heapify(int arr[], int n, int i) {
        int largest = i; // 初始化largest为root
        int left = 2*i + 1; // 左子节点
        int right = 2*i + 2; // 右子节点

        // 如果左子节点大于根
        if (left < n && arr[left] > arr[largest])
            largest = left;

        // 如果右子节点大于目前的最大值
        if (right < n && arr[right] > arr[largest])
            largest = right;

        // 如果最大值不是root
        if (largest != i) {
            int swap = arr[i];
            arr[i] = arr[largest];
            arr[largest] = swap;

            // 递归地调整受影响的子树
            heapify(arr, n, largest);
        }
    }
}
```

### 堆排序 优缺点及应用场景

- **优点**：在最坏情况下时间复杂度也是 O(n log n)，并且它是原地排序算法，不需要额外的空间。
- **缺点**：相比其他高效的排序算法如快速排序，堆排序通常较慢；此外，它不是一个稳定的排序算法。
- **应用场景**：适用于需要稳定时间复杂度的应用场景，尤其是当内存空间有限时。

### 堆排序 复杂度

- 时间复杂度：
  - 最好、平均和最坏情况均为 O(n log n)
- 空间复杂度：O(1)

### 堆排序 是否稳定

堆排序是**不稳定的排序算法**，因为在调整堆的过程中可能会改变相同元素的相对顺序。

### 堆排序 手动排序示例

假设我们有一个数组 `[4, 10, 3, 5, 1]`。

1. 首先构建最大堆：
   - 初始数组：`[4, 10, 3, 5, 1]`
   - 经过heapify操作后形成最大堆：`[10, 5, 3, 4, 1]`

2. 第一次交换并重建堆：
   - 交换第一个元素和最后一个元素：`[1, 5, 3, 4, 10]`
   - 重建堆（忽略已排序部分 `[10]`）：`[5, 4, 3, 1, 10]`

3. 第二次交换并重建堆：
   - 交换第一个元素和倒数第二个元素：`[1, 4, 3, 5, 10]`
   - 重建堆（忽略已排序部分 `[5, 10]`）：`[4, 1, 3, 5, 10]`

4. 第三次交换并重建堆：
   - 交换第一个元素和倒数第三个元素：`[1, 1, 3, 4, 10]`
   - 重建堆（忽略已排序部分 `[4, 5, 10]`）：`[3, 1, 1, 4, 10]`

5. 第四次交换并重建堆：
   - 交换第一个元素和倒数第四个元素：`[1, 1, 3, 4, 10]`
   - 因为只剩两个元素，直接交换即可完成排序：`[1, 1, 3, 4, 10]`

最终结果为已排序的数组 `[1, 1, 3, 4, 10]`。  
请注意，在实际的手动排序过程中，可能需要多次应用 heapify 函数来确保堆的性质得到维持。上述步骤简化了一些细节，以便于理解。

## 7. 计数排序 （Counting Sort）

### 计数排序 核心思想

计数排序是一种非比较型整数排序算法，适用于一定范围内的整数排序。  
它通过计算每个数值出现的次数来确定每个元素在输出数组中的位置。其主要思想是使用一个额外的数组 C，其中 `C[i]`  记录了待排序数组中值等于 i 的元素个数。

### 计数排序 实现步骤

1. 找出待排序数组中的最大值 k，以确定计数数组 C 的大小。
2. 初始化计数数组 C，长度为 k+1，并将所有元素初始化为 0。
3. 遍历待排序数组，对于每个值 A[i]，在计数数组 C 中对应位置 C[A[i]]增加 1。
4. 修改计数数组 C，使得 C[i]包含小于或等于 i 的所有元素的个数。
5. 根据计数数组 C，将各个元素放置到正确的位置上，构建输出数组 B。

### 计数排序 JAVA 代码模板

```java
public class CountingSort {
    public static void sort(int[] array) {
        int max = findMax(array); // 找出数组中的最大值

        int[] countArray = new int[max + 1]; // 创建计数数组

        // 统计每个值出现的次数
        for (int number : array) {
            countArray[number]++;
        }

        // 修改计数数组，使其包含实际位置信息
        for (int i = 1; i < countArray.length; i++) {
            countArray[i] += countArray[i - 1];
        }

        int[] output = new int[array.length]; // 输出数组
        // 根据计数数组构建输出数组
        for (int i = array.length - 1; i >= 0; i--) {
            output[countArray[array[i]] - 1] = array[i];
            countArray[array[i]]--;
        }

        // 将排序结果复制回原数组
        System.arraycopy(output, 0, array, 0, array.length);
    }

    private static int findMax(int[] array) {
        int max = array[0];
        for (int i = 1; i < array.length; i++) {
            if (array[i] > max) {
                max = array[i];
            }
        }
        return max;
    }
}
```

### 计数排序 优缺点及应用场景

- **优点**：时间复杂度为 $O(n+k)$，其中 n 是输入数组的大小，k 是输入数组中最大值和最小值的差；当 k 不是很大时，效率非常高；稳定排序算法。
- **缺点**：当 k 非常大时（如数据范围远大于待排序元素数量），空间消耗会变得非常大；仅适用于整数排序。
- **应用场景**：特别适合用于排序范围有限的整数集合，例如考试成绩、年龄等。

### 计数排序 复杂度

- 时间复杂度：$O(n+k)$
- 空间复杂度：$O(k)$

### 计数排序 是否稳定

计数排序是一种稳定的排序算法，因为相同值的相对顺序不会改变。

### 计数排序 手动排序示例

假设我们有一个数组 `[4, 2, 2, 8, 3, 3, 1]`。

1. 找出最大值：8
2. 初始化计数数组 C，长度为 9（从 0 到 8）：

   ``` plaintext
   C: [0, 0, 0, 0, 0, 0, 0, 0, 0]
   ```

3. 统计每个值出现的次数：

   ``` plaintext
   C: [1, 1, 2, 2, 1, 0, 0, 0, 1]
   ```

4. 修改计数数组 C，使其包含小于或等于 i 的所有元素的个数：

   ``` plaintext
   C: [1, 2, 4, 6, 7, 7, 7, 7, 8]
   ```

5. 构建输出数组 B：
   - 对于值 1，在位置 1 处放入 1
   - 对于值 2，在位置 2 和位置 4 处分别放入 2
   - 对于值 3，在位置 5 和位置 6 处分别放入 3
   - 对于值 4，在位置 7 处放入 4
   - 对于值 8，在位置 8 处放入 8

最终得到有序数组 `[1, 2, 2, 3, 3, 4, 8]`。  
注意，在构建输出数组时，为了保持稳定性，我们需要从后向前遍历原始数组。这样可以确保如果两个元素相等，它们在输出数组中的相对顺序与在输入数组中的顺序相同。

## 8. 桶排序 （Bucket Sort）

### 桶排序 核心思想

桶排序是一种分布式的排序算法。  
它基于将数据分发到多个“桶”中，每个桶单独进行排序（通常使用其他排序算法如快速排序），然后依次连接这些桶来得到最终的排序结果。桶排序非常适合用于数据均匀分布的情况。

### 桶排序 实现步骤

1. **设置桶的数量**：根据输入数据的范围和分布情况决定桶的数量。
2. **分配元素到桶中**：遍历原始数组，根据某种映射规则（通常是值的比例或哈希函数）将各个元素放入对应的桶中。
3. **对每个桶内的元素进行排序**：可以使用任何适合的内部排序算法对每个桶中的元素进行排序。
4. **合并所有桶的结果**：按照顺序收集每个桶中的元素，形成最终的有序序列。

### 桶排序 JAVA 代码模板

```java
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public class BucketSort {

    public static void sort(float[] arr) {
        if (arr.length == 0) {
            return;
        }

        // 找出最大最小值确定桶的范围
        float minValue = arr[0];
        float maxValue = arr[0];
        for (float value : arr) {
            if (value < minValue) {
                minValue = value;
            } else if (value > maxValue) {
                maxValue = value;
            }
        }

        // 初始化桶
        int bucketCount = arr.length;
        List<List<Float>> buckets = new ArrayList<>(bucketCount);
        for (int i = 0; i < bucketCount; i++) {
            buckets.add(new ArrayList<>());
        }

        // 分配元素到桶中
        for (float value : arr) {
            int bucketIndex = (int) ((value - minValue) / (maxValue - minValue + 1) * bucketCount);
            buckets.get(bucketIndex).add(value);
        }

        // 对每个桶进行排序，并合并结果
        int currentIndex = 0;
        for (List<Float> bucket : buckets) {
            Collections.sort(bucket); // 使用内置排序算法对桶内元素排序
            for (float value : bucket) {
                arr[currentIndex++] = value;
            }
        }
    }
}
```

### 桶排序 优缺点及应用场景

- **优点**：对于特定类型的数据（如浮点数或均匀分布的整数），桶排序能够提供线性时间复杂度 O(n)，效率非常高；稳定排序。
- **缺点**：桶排序的表现高度依赖于输入数据的分布情况；当输入数据不均匀时，可能导致某些桶过大，影响性能。
- **应用场景**：特别适用于外部排序、海量数据排序以及数据分布较为均匀的情况。

### 桶排序 复杂度

- 时间复杂度：平均情况下为 $O(n+k)$，其中 n 是待排序元素数量，k 是桶的数量；最坏情况下取决于使用的内部排序算法，可能退化至 $O(n^2)$。
- 空间复杂度：$O(n+k)$

### 桶排序 是否稳定

桶排序是**稳定的排序算法**，因为它在分配元素到桶时不改变元素之间的相对位置，并且在对桶内元素进行排序时可以选择稳定的排序算法。

### 桶排序 手动排序示例

假设我们有一个数组 `[0.78, 0.17, 0.39, 0.26, 0.72, 0.94, 0.21, 0.12, 0.23, 0.68]`。

1. 首先找到最大值和最小值分别为 `0.94` 和 `0.12`。
2. 假设我们创建5个桶，则每个桶负责的范围是 `(0.94 - 0.12) / 5 = 0.164`。
3. 根据每个数值落在的区间将其分配到对应的桶中：
   - 桶0: `[0.12, 0.17]`
   - 桶1: `[0.21, 0.23, 0.26]`
   - 桶2: `[0.39]`
   - 桶3: `[0.68]`
   - 桶4: `[0.72, 0.78, 0.94]`
4. 对每个桶中的元素进行排序（这里因为桶内元素较少可以直接看出排序结果）：
   - 桶0: `[0.12, 0.17]`
   - 桶1: `[0.21, 0.23, 0.26]`
   - 桶2: `[0.39]`
   - 桶3: `[0.68]`
   - 桶4: `[0.72, 0.78, 0.94]`
5. 合并所有桶的结果得到最终的有序数组：`[0.12, 0.17, 0.21, 0.23, 0.26, 0.39, 0.68, 0.72, 0.78, 0.94]`

通过上述步骤，可以看到如何使用桶排序逐步处理一个数组，直到获得完全排序的结果。

## 9. 基数排序 （Radix Sort）

### 基数排序 核心思想

基数排序是一种非比较型排序算法，主要用于整数的排序。  
它通过逐位比较数字来实现排序（从最低有效位到最高有效位或相反）。基数排序可以分为两种：LSD（Least Significant Digit）和 MSD（Most Significant Digit），分别从最不重要的位（右边）和最重要的位（左边）开始排序。

### 基数排序 实现步骤

1. **确定最大数**：找出待排序数组中的最大数，以确定最长的数字长度。
2. **分配和收集**：根据每个数字的个位、十位、百位...等进行分配（放入对应基数桶中）和收集（按顺序从桶中取出）。这个过程需要重复执行，直到处理完所有位数。
3. **重复步骤 2**：对于每一位重复分配和收集的过程，直到所有位都处理完毕。

### 基数排序 JAVA 代码模板

```java
import java.util.LinkedList;
import java.util.Queue;

public class RadixSort {

    public static void sort(int[] arr) {
        int max = getMax(arr);

        // 根据每个位数进行排序
        for (int exp = 1; max / exp > 0; exp *= 10) {
            countingSortByDigit(arr, exp);
        }
    }

    private static void countingSortByDigit(int[] arr, int exp) {
        Queue<Integer>[] buckets = new Queue[10];
        for (int i = 0; i < 10; i++) {
            buckets[i] = new LinkedList<>();
        }

        // 分配过程
        for (int value : arr) {
            int bucketIndex = (value / exp) % 10;
            buckets[bucketIndex].add(value);
        }

        // 收集过程
        int arrayIndex = 0;
        for (Queue<Integer> bucket : buckets) {
            while (!bucket.isEmpty()) {
                arr[arrayIndex++] = bucket.remove();
            }
        }
    }

    private static int getMax(int[] arr) {
        int max = arr[0];
        for (int value : arr) {
            if (value > max) {
                max = value;
            }
        }
        return max;
    }
}
```

### 基数排序 优缺点及应用场景

- **优点**：时间复杂度为 $O(n*k)$，其中 n 是输入数组的大小，k 是数字的最大长度；适用于大规模数据排序；稳定排序算法。
- **缺点**：空间复杂度较高，因为需要额外的空间存储桶；仅适用于整数或字符串等固定宽度的数据类型。
- **应用场景**：特别适合用于整数或长度固定的字符串排序，在需要高效处理大规模数据时非常有用。

### 基数排序 复杂度

- 时间复杂度：$O(n*k)$
- 空间复杂度：$O(n+k)$

### 基数排序 是否稳定

基数排序是一种**稳定的排序算法**，因为在同一轮次内相同数值的相对顺序不会改变。

### 基数排序 手动排序示例

假设我们有一个数组 `[170, 45, 75, 90, 802, 24, 2, 66]`。

1. **确定最大数**：802
2. **对个位数进行排序**：
   - 初始数组：`[170, 45, 75, 90, 802, 24, 2, 66]`
   - 经过一轮分配和收集后：`[170, 90, 802, 2, 24, 45, 75, 66]`

3. **对十位数进行排序**：
   - 使用上一步结果：`[170, 90, 802, 2, 24, 45, 75, 66]`
   - 经过一轮分配和收集后：`[802, 2, 24, 45, 66, 170, 75, 90]`

4. **对百位数进行排序**：
   - 使用上一步结果：`[802, 2, 24, 45, 66, 170, 75, 90]`
   - 经过一轮分配和收集后：`[2, 24, 45, 66, 75, 90, 170, 802]`

最终得到有序数组 `[2, 24, 45, 66, 75, 90, 170, 802]`。

通过上述步骤，可以看到如何使用基数排序逐步处理一个数组，直到获得完全排序的结果。  
每一步都是基于当前考虑的位数将数字分配到对应的桶中，然后再从这些桶中依次取出数字形成新的序列。

## 10. 希尔排序 （Shell Sort）

### 希尔排序 核心思想

希尔排序（Shell Sort）是插入排序的一种改进版本，也被称为“缩小增量排序”。  
其基本思想是通过比较距离较远的元素来减少数据移动次数，从而更快地将数组变得接近有序。随着排序的进行，逐步减小这个距离，直到它变为 1，此时的希尔排序就退化为普通的插入排序。

### 希尔排序 实现步骤

1. **选择增量序列**：首先选定一个初始增量值 `gap`，该值小于数组长度，并逐步减小。
2. **分组和排序**：根据当前的增量值 `gap`，将数组分为若干个子序列，每个子序列中的元素索引相差 `gap`。对每个子序列使用插入排序进行排序。
3. **调整增量并重复**：减小增量值（通常除以某个常数，如 2），重复上述过程，直到增量值变为 1。当增量为 1 时，整个数组被视为一个子序列进行最后一次插入排序，确保最终结果有序。

### 希尔排序 JAVA 代码模板

```java
public class ShellSort {
    public void sort(int[] arr) {
        int n = arr.length;

        // 初始增量值设为数组长度的一半
        for (int gap = n / 2; gap > 0; gap /= 2) {
            // 对每个间隔进行插入排序
            for (int i = gap; i < n; i++) {
                int temp = arr[i];
                int j;
                // 插入排序
                for (j = i; j >= gap && arr[j - gap] > temp; j -= gap) {
                    arr[j] = arr[j - gap];
                }
                arr[j] = temp;
            }
        }
    }

    // 打印数组
    public void printArray(int arr[]) {
        for (int i = 0; i < arr.length; ++i)
            System.out.print(arr[i] + " ");
        System.out.println();
    }
}
```

### 希尔排序 优缺点及应用场景

- **优点**：对于中等规模的数据集来说，希尔排序比简单的插入排序要快得多；不需要额外的空间，是一种原地排序算法。
- **缺点**：实现较为复杂，且其性能高度依赖于所选的增量序列；不是稳定的排序算法。
- **应用场景**：适用于中小规模的数据集；在某些情况下，尤其是当内存访问模式对性能有显著影响时，希尔排序可能优于其他 O(n log n)的算法。

### 希尔排序 复杂度

- 时间复杂度：取决于增量序列的选择，最坏情况可以达到 O(n^2)，但在实践中通常表现得更好，平均情况大约为 O(n^1.5)。
- 空间复杂度：O(1)

### 希尔排序 是否稳定

希尔排序不是一个稳定的排序算法，因为在处理不同间隔的子序列时可能会改变相同元素的相对顺序。

### 希尔排序 手动排序示例

假设我们有一个数组 `[12, 34, 54, 2, 3]`。

1. **初始增量值**：`n/2 = 2`
   - 分组：`[12, 2], [34, 3], [54]`
   - 对每组进行插入排序：
     - 第一组：`[2, 12]`
     - 第二组：`[3, 34]`
     - 第三组只有一个元素，无需排序
   - 结果：`[2, 34, 12, 3, 54]`

1. **增量值变为 1**：
   - 直接对整个数组进行插入排序：
     - `2` 已经在正确位置
     - `34` 比较后发现需要与 `12` 交换 -> `[2, 12, 34, 3, 54]`
     - `3` 需要移动到前面 -> `[2, 3, 12, 34, 54]`
     - `54` 已经在正确位置

最终得到有序数组 `[2, 3, 12, 34, 54]`。

通过上述步骤，可以看到如何使用希尔排序逐步处理一个数组，直到获得完全排序的结果。每次调整增量值后，数组都会变得更加有序，这使得最后一步的插入排序效率更高。
