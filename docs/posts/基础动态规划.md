---
description: 基础动态规划题目，通常是选或不选题目的解题思路
tags:
    - 算法
---

# 基础动态规划解题思路

## 主要解题思路
主要步骤划分为三步：
1. 使用回溯解题。
2. 将回溯加上记忆化搜索。
3. 1:1 翻译为递推（写成动态规划）。

### 回溯解题思路
回溯解题的关键在于识别题目中的四要素：
1. **选择列表**：当前可用的决策选项。
2. **路径**：已经做出的决策。
3. **终止条件**：结束递归的条件判断。
4. **剪枝条件**：提前终止无效分支的条件判断。

#### 代码模板
``` java
private void backtrack(/* 选择列表 */， /* 路径 */){
    if( /* 满足终止条件 */){
        // 记录数据，将路径添加到结果中
        return;
    }

    for( /* 选择 */ in /* 选择列表 */){
        if(/* 不符合剪枝条件 */){
            // 做出选择（将选择添加到路径中）
            backtrack(/* 新的选择列表（或是选择列表的新的起始位置） */, /* 路径 */);
            // 撤销选择，恢复现场（将选择从路径中移出）
        }
    }
}
```

#### 示例
- 打家劫舍
  - 选择列表：根据是否选择而变化。如果选择打劫，则下一家从选择列表中去除；如果选择不打劫，则选择列表中下一家开始。
  - 操作：选或不选。
  - 路径：实际上记录的是当前打劫之后的金额。
  - 终止条件：递归到最后一家完成，即 i < 0。

- 全排列
  - 选择列表：根据是否使用而变化。如果选择使用，则将其选择列表去除。
  - 操作：从未使用的列表中选择出一个数字填到当前位置。
  - 路径：已经填入的数字的列表。
  - 终止条件：路径长度等于数组长度，即所有元素都被选择。

- 爬楼梯
  - 选择列表：可以移动的距离。
  - 操作：从可以移动的距离中选择一个，选或不选。
  - 路径：已经移动的距离，或是移动到当前距离的花费最小值。
  - 终止条件：到达底部， i < 0。

### 记忆化搜索
记忆化搜索实际上就将代码运行中的一些中间值记录下来 ，避免重复计算。

例如在爬楼梯中，我们可能会重复地多次计算同一位置上的最小耗费。因为我们的回溯代码是递归执行的，所以递归到的重复步骤还是会被计算。  
引入 `int[] memo` 记录在位置 `i` 处的最小耗费。在运行中如果 `memo[i]!=-1`，直接返回其值，无需进行计算。

### 1:1 翻译成递推
将 `dfs` 转换为 `f` 数组，递归转换为循环，递归边界转换为 `f` 数组初始值。
